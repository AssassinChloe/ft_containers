    
    template <class Category, class T, class Distance = ptrdiff_t,
          class Pointer = T*, class Reference = T&>
  struct iterator {
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
  };
    
    namespace ft
    {
        class iterator { 
        public:
            typedef typename std::allocator<T>::difference_type difference_type;
            typedef typename std::allocator<T>::value_type value_type;
            typedef typename std::allocator<T>::reference reference;
            typedef typename std::allocator<T>::pointer pointer;
            typedef std::random_access_iterator_tag iterator_category; //or another tag

            iterator();
            iterator(const iterator&);
            ~iterator();

            iterator& operator=(const iterator&);
            bool operator==(const iterator&) const;
            bool operator!=(const iterator&) const;
            bool operator<(const iterator&) const; //optional
            bool operator>(const iterator&) const; //optional
            bool operator<=(const iterator&) const; //optional
            bool operator>=(const iterator&) const; //optional

            iterator& operator++();
            iterator operator++(int); //optional
            iterator& operator--(); //optional
            iterator operator--(int); //optional
            iterator& operator+=(size_type); //optional
            iterator operator+(size_type) const; //optional
            friend iterator operator+(size_type, const iterator&); //optional
            iterator& operator-=(size_type); //optional            
            iterator operator-(size_type) const; //optional
            difference_type operator-(iterator) const; //optional

            reference operator*() const;
            pointer operator->() const;
            reference operator[](size_type) const; //optional
        };

        class const_iterator {
        public:
            typedef typename A::difference_type difference_type;
            typedef typename A::value_type value_type;
            typedef typename const A::reference reference;
            typedef typename const A::pointer pointer;
            typedef std::random_access_iterator_tag iterator_category; //or another tag

            const_iterator ();
            const_iterator (const const_iterator&);
            const_iterator (const iterator&);
            ~const_iterator();

            const_iterator& operator=(const const_iterator&);
            bool operator==(const const_iterator&) const;
            bool operator!=(const const_iterator&) const;
            bool operator<(const const_iterator&) const; //optional
            bool operator>(const const_iterator&) const; //optional
            bool operator<=(const const_iterator&) const; //optional
            bool operator>=(const const_iterator&) const; //optional

            const_iterator& operator++();
            const_iterator operator++(int); //optional
            const_iterator& operator--(); //optional
            const_iterator operator--(int); //optional
            const_iterator& operator+=(size_type); //optional
            const_iterator operator+(size_type) const; //optional
            friend const_iterator operator+(size_type, const const_iterator&); //optional
            const_iterator& operator-=(size_type); //optional            
            const_iterator operator-(size_type) const; //optional
            difference_type operator-(const_iterator) const; //optional

            reference operator*() const;
            pointer operator->() const;
            reference operator[](size_type) const; //optional
        };

        typedef std::reverse_iterator<iterator> reverse_iterator; //optional
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator; //optional
    }